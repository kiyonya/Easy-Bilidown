import { writeFileSync } from "fs"

export default class DanmakuProcessor {
    constructor(cid, { duration = 3, screenWidth = 1920, screenHeight = 1080 } = options) {
        this.duration = duration
        this.screenWidth = screenWidth
        this.screenHeight = screenHeight
        this.cid = cid
        this.xml = ''
        this.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        }
        this.assHead = `[Script Info]
; Generated by Danmaku to ASS Converter
Title: B站弹幕转ASS字幕
ScriptType: v4.00+
WrapStyle: 0
PlayResX: ${this.screenWidth}
PlayResY: ${this.screenHeight}

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,36,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,0,5,0,0,0,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`
    }
    async fetchXML() {
        let url = `https://comment.bilibili.com/${this.cid}.xml`
        const res = await fetch(url, {
            headers: this.headers,
            method: 'get'
        })
        if (res.ok) {
            let text = await res.text()
            return text
        }
        return null
    }
    async toAss(fileName) {
        this.xml = await this.fetchXML()
        if(!this.xml){return}
        let ass = this.convertDanmakuToASS(this.xml)
        writeFileSync(fileName, ass, 'utf-8')
        return { type: 'danmakuAss', path: fileName }
    }
    async toXml(fileName) {
        this.xml = await this.fetchXML()
        if(!this.xml){return}
        writeFileSync(fileName, this.xml, 'utf-8')
        return { type: 'danmakuXml', path: fileName }
    }
    convertDanmakuToASS(xmlText) {
        const danmakuList = [];
        const regex = /<d p="([^"]+)">([^<]+)<\/d>/g;
        let match;
        while ((match = regex.exec(xmlText)) !== null) {
            const [_, p, text] = match;
            const params = p.split(',');
            danmakuList.push({
                time: parseFloat(params[0]),
                mode: parseInt(params[1]),
                fontSize: parseInt(params[2]),
                color: params[3],
                text: text.trim()
            });
        }
        let assContent = `[Script Info]
; Generated by Danmaku to ASS Converter
Title: B站弹幕转ASS字幕
ScriptType: v4.00+
WrapStyle: 0
PlayResX: 1280
PlayResY: 720

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Fix,Arial,36,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,0,5,20,20,2,1
Style: R2L,Arial,36,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,0,5,20,20,2,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;
        danmakuList.forEach(danmaku => {
            const startTime = this.formatTime(danmaku.time);
            const endTime = this.formatTime(danmaku.time + 8);
            let colorHex;
            if (/^[0-9]+$/.test(danmaku.color)) {
                colorHex = parseInt(danmaku.color).toString(16).padStart(6, '0');
            } else {
                colorHex = danmaku.color.replace(/^0x/, '').slice(-6).padStart(6, '0');
            }
            const assColor = `&H${colorHex.slice(4, 6)}${colorHex.slice(2, 4)}${colorHex.slice(0, 2)}`;
            let style = "Fix";
            let effect = "";
            switch (danmaku.mode) {
                case 1:
                case 2:
                case 3:
                    style = "R2L";
                    const startX = 1280;
                    const endX = -100;
                    const yPos = 25 + (Math.random() * 400);
                    effect = `{\\move(${startX},${yPos},${endX},${yPos})\\c${assColor}\\fs${danmaku.fontSize}}`;
                    break;
                case 4:
                    style = "Fix";
                    effect = `{\\pos(280,650)\\c${assColor}\\fs${danmaku.fontSize}}`;
                    break;
                case 5: // 顶部固定
                    style = "Fix";
                    effect = `{\\pos(280,25)\\c${assColor}\\fs${danmaku.fontSize}}`; // 顶部居中
                    break;
                default: // 默认居中固定
                    style = "Fix";
                    effect = `{\\pos(280,360)\\c${assColor}\\fs${danmaku.fontSize}}`; // 屏幕中央
            }

            assContent += `Dialogue: 0,${startTime},${endTime},${style},,20,20,2,,${effect}${danmaku.text}\n`;
        });

        return assContent;
    }
    formatTime(seconds) {
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = seconds % 60;
        return `${h}:${m.toString().padStart(2, '0')}:${s.toFixed(2).padStart(5, '0')}`;
    }
    getRandomY() {
        return Math.floor(Math.random() * 600 + 100);
    }
}


